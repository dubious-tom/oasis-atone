// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: osmosis/gamm/v1beta1/tx.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-sdk/types"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// ===================== MsgJoinPool
type MaxAmountIn struct {
	Denom     string                                 `protobuf:"bytes,1,opt,name=denom,proto3" json:"denom,omitempty" yaml:"denom"`
	MaxAmount github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,2,opt,name=maxAmount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"maxAmount" yaml:"max_amount"`
}

func (m *MaxAmountIn) Reset()         { *m = MaxAmountIn{} }
func (m *MaxAmountIn) String() string { return proto.CompactTextString(m) }
func (*MaxAmountIn) ProtoMessage()    {}
func (*MaxAmountIn) Descriptor() ([]byte, []int) {
	return fileDescriptor_cfc8fd3ac7df3247, []int{0}
}
func (m *MaxAmountIn) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MaxAmountIn) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MaxAmountIn.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MaxAmountIn) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MaxAmountIn.Merge(m, src)
}
func (m *MaxAmountIn) XXX_Size() int {
	return m.Size()
}
func (m *MaxAmountIn) XXX_DiscardUnknown() {
	xxx_messageInfo_MaxAmountIn.DiscardUnknown(m)
}

var xxx_messageInfo_MaxAmountIn proto.InternalMessageInfo

func (m *MaxAmountIn) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

type MsgJoinPool struct {
	Sender        github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,1,opt,name=sender,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"sender,omitempty" yaml:"sender"`
	TargetPoolId  uint64                                        `protobuf:"varint,2,opt,name=targetPoolId,proto3" json:"targetPoolId,omitempty" yaml:"target_pool_id"`
	PoolAmountOut github_com_cosmos_cosmos_sdk_types.Int        `protobuf:"bytes,3,opt,name=poolAmountOut,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"poolAmountOut" yaml:"pool_amount_out"`
	MaxAmountsIn  []MaxAmountIn                                 `protobuf:"bytes,4,rep,name=maxAmountsIn,proto3" json:"maxAmountsIn" yaml:"max_amounts_in"`
}

func (m *MsgJoinPool) Reset()         { *m = MsgJoinPool{} }
func (m *MsgJoinPool) String() string { return proto.CompactTextString(m) }
func (*MsgJoinPool) ProtoMessage()    {}
func (*MsgJoinPool) Descriptor() ([]byte, []int) {
	return fileDescriptor_cfc8fd3ac7df3247, []int{1}
}
func (m *MsgJoinPool) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgJoinPool) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgJoinPool.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgJoinPool) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgJoinPool.Merge(m, src)
}
func (m *MsgJoinPool) XXX_Size() int {
	return m.Size()
}
func (m *MsgJoinPool) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgJoinPool.DiscardUnknown(m)
}

var xxx_messageInfo_MsgJoinPool proto.InternalMessageInfo

func (m *MsgJoinPool) GetSender() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.Sender
	}
	return nil
}

func (m *MsgJoinPool) GetTargetPoolId() uint64 {
	if m != nil {
		return m.TargetPoolId
	}
	return 0
}

func (m *MsgJoinPool) GetMaxAmountsIn() []MaxAmountIn {
	if m != nil {
		return m.MaxAmountsIn
	}
	return nil
}

// ===================== MsgExitPool
type MinAmountOut struct {
	Denom     string                                 `protobuf:"bytes,1,opt,name=denom,proto3" json:"denom,omitempty" yaml:"denom"`
	MinAmount github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,2,opt,name=minAmount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"minAmount" yaml:"min_amount"`
}

func (m *MinAmountOut) Reset()         { *m = MinAmountOut{} }
func (m *MinAmountOut) String() string { return proto.CompactTextString(m) }
func (*MinAmountOut) ProtoMessage()    {}
func (*MinAmountOut) Descriptor() ([]byte, []int) {
	return fileDescriptor_cfc8fd3ac7df3247, []int{2}
}
func (m *MinAmountOut) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MinAmountOut) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MinAmountOut.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MinAmountOut) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MinAmountOut.Merge(m, src)
}
func (m *MinAmountOut) XXX_Size() int {
	return m.Size()
}
func (m *MinAmountOut) XXX_DiscardUnknown() {
	xxx_messageInfo_MinAmountOut.DiscardUnknown(m)
}

var xxx_messageInfo_MinAmountOut proto.InternalMessageInfo

func (m *MinAmountOut) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

type MsgExitPool struct {
	Sender        github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,1,opt,name=sender,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"sender,omitempty" yaml:"sender"`
	TargetPoolId  uint64                                        `protobuf:"varint,2,opt,name=targetPoolId,proto3" json:"targetPoolId,omitempty" yaml:"target_pool_id"`
	PoolAmountIn  github_com_cosmos_cosmos_sdk_types.Int        `protobuf:"bytes,3,opt,name=poolAmountIn,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"poolAmountIn" yaml:"pool_amount_in"`
	MinAmountsOut []MinAmountOut                                `protobuf:"bytes,4,rep,name=minAmountsOut,proto3" json:"minAmountsOut" yaml:"min_amounts_out"`
}

func (m *MsgExitPool) Reset()         { *m = MsgExitPool{} }
func (m *MsgExitPool) String() string { return proto.CompactTextString(m) }
func (*MsgExitPool) ProtoMessage()    {}
func (*MsgExitPool) Descriptor() ([]byte, []int) {
	return fileDescriptor_cfc8fd3ac7df3247, []int{3}
}
func (m *MsgExitPool) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgExitPool) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgExitPool.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgExitPool) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgExitPool.Merge(m, src)
}
func (m *MsgExitPool) XXX_Size() int {
	return m.Size()
}
func (m *MsgExitPool) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgExitPool.DiscardUnknown(m)
}

var xxx_messageInfo_MsgExitPool proto.InternalMessageInfo

func (m *MsgExitPool) GetSender() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.Sender
	}
	return nil
}

func (m *MsgExitPool) GetTargetPoolId() uint64 {
	if m != nil {
		return m.TargetPoolId
	}
	return 0
}

func (m *MsgExitPool) GetMinAmountsOut() []MinAmountOut {
	if m != nil {
		return m.MinAmountsOut
	}
	return nil
}

// ===================== MsgCreatePool
type LPTokenInfo struct {
	Denom       string `protobuf:"bytes,1,opt,name=denom,proto3" json:"denom,omitempty" yaml:"denom"`
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty" yaml:"description"`
}

func (m *LPTokenInfo) Reset()         { *m = LPTokenInfo{} }
func (m *LPTokenInfo) String() string { return proto.CompactTextString(m) }
func (*LPTokenInfo) ProtoMessage()    {}
func (*LPTokenInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_cfc8fd3ac7df3247, []int{4}
}
func (m *LPTokenInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LPTokenInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LPTokenInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LPTokenInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LPTokenInfo.Merge(m, src)
}
func (m *LPTokenInfo) XXX_Size() int {
	return m.Size()
}
func (m *LPTokenInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_LPTokenInfo.DiscardUnknown(m)
}

var xxx_messageInfo_LPTokenInfo proto.InternalMessageInfo

func (m *LPTokenInfo) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

func (m *LPTokenInfo) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

type BindTokenInfo struct {
	Denom  string                                 `protobuf:"bytes,1,opt,name=denom,proto3" json:"denom,omitempty" yaml:"denom"`
	Weight github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,2,opt,name=weight,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"weight" yaml:"weight"`
	Amount github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,3,opt,name=amount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"amount" yaml:"amount"`
}

func (m *BindTokenInfo) Reset()         { *m = BindTokenInfo{} }
func (m *BindTokenInfo) String() string { return proto.CompactTextString(m) }
func (*BindTokenInfo) ProtoMessage()    {}
func (*BindTokenInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_cfc8fd3ac7df3247, []int{5}
}
func (m *BindTokenInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BindTokenInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BindTokenInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BindTokenInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BindTokenInfo.Merge(m, src)
}
func (m *BindTokenInfo) XXX_Size() int {
	return m.Size()
}
func (m *BindTokenInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_BindTokenInfo.DiscardUnknown(m)
}

var xxx_messageInfo_BindTokenInfo proto.InternalMessageInfo

func (m *BindTokenInfo) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

type MsgCreatePool struct {
	Sender     github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,1,opt,name=sender,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"sender,omitempty" yaml:"sender"`
	SwapFee    github_com_cosmos_cosmos_sdk_types.Dec        `protobuf:"bytes,2,opt,name=swapFee,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"swapFee" yaml:"swap_fee"`
	LpToken    LPTokenInfo                                   `protobuf:"bytes,3,opt,name=lpToken,proto3" json:"lpToken" yaml:"lp_token"`
	BindTokens []BindTokenInfo                               `protobuf:"bytes,4,rep,name=bindTokens,proto3" json:"bindTokens" yaml:"token_info"`
}

func (m *MsgCreatePool) Reset()         { *m = MsgCreatePool{} }
func (m *MsgCreatePool) String() string { return proto.CompactTextString(m) }
func (*MsgCreatePool) ProtoMessage()    {}
func (*MsgCreatePool) Descriptor() ([]byte, []int) {
	return fileDescriptor_cfc8fd3ac7df3247, []int{6}
}
func (m *MsgCreatePool) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreatePool) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreatePool.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreatePool) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreatePool.Merge(m, src)
}
func (m *MsgCreatePool) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreatePool) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreatePool.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreatePool proto.InternalMessageInfo

func (m *MsgCreatePool) GetSender() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.Sender
	}
	return nil
}

func (m *MsgCreatePool) GetLpToken() LPTokenInfo {
	if m != nil {
		return m.LpToken
	}
	return LPTokenInfo{}
}

func (m *MsgCreatePool) GetBindTokens() []BindTokenInfo {
	if m != nil {
		return m.BindTokens
	}
	return nil
}

// ===================== MsgSwapExactAmountIn
type MsgSwapExactAmountIn struct {
	Sender        github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,1,opt,name=sender,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"sender,omitempty" yaml:"sender"`
	TargetPoolId  uint64                                        `protobuf:"varint,2,opt,name=targetPoolId,proto3" json:"targetPoolId,omitempty" yaml:"target_pool_id"`
	TokenIn       github_com_cosmos_cosmos_sdk_types.Coin       `protobuf:"bytes,3,opt,name=tokenIn,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Coin" json:"tokenIn" yaml:"token_in"`
	TokenAmountIn github_com_cosmos_cosmos_sdk_types.Int        `protobuf:"bytes,4,opt,name=tokenAmountIn,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"tokenAmountIn" yaml:"token_amount_in"`
	TokenOut      github_com_cosmos_cosmos_sdk_types.Coin       `protobuf:"bytes,5,opt,name=tokenOut,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Coin" json:"tokenOut" yaml:"token_out"`
	MinAmountOut  github_com_cosmos_cosmos_sdk_types.Int        `protobuf:"bytes,6,opt,name=minAmountOut,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"minAmountOut" yaml:"min_amount_out"`
	MaxPrice      github_com_cosmos_cosmos_sdk_types.Int        `protobuf:"bytes,7,opt,name=maxPrice,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"maxPrice" yaml:"max_price"`
}

func (m *MsgSwapExactAmountIn) Reset()         { *m = MsgSwapExactAmountIn{} }
func (m *MsgSwapExactAmountIn) String() string { return proto.CompactTextString(m) }
func (*MsgSwapExactAmountIn) ProtoMessage()    {}
func (*MsgSwapExactAmountIn) Descriptor() ([]byte, []int) {
	return fileDescriptor_cfc8fd3ac7df3247, []int{7}
}
func (m *MsgSwapExactAmountIn) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSwapExactAmountIn) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSwapExactAmountIn.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSwapExactAmountIn) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSwapExactAmountIn.Merge(m, src)
}
func (m *MsgSwapExactAmountIn) XXX_Size() int {
	return m.Size()
}
func (m *MsgSwapExactAmountIn) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSwapExactAmountIn.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSwapExactAmountIn proto.InternalMessageInfo

func (m *MsgSwapExactAmountIn) GetSender() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.Sender
	}
	return nil
}

func (m *MsgSwapExactAmountIn) GetTargetPoolId() uint64 {
	if m != nil {
		return m.TargetPoolId
	}
	return 0
}

// ===================== MsgSwapExactAmountOut
type MsgSwapExactAmountOut struct {
	Sender         github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,1,opt,name=sender,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"sender,omitempty" yaml:"sender"`
	TargetPoolId   uint64                                        `protobuf:"varint,2,opt,name=targetPoolId,proto3" json:"targetPoolId,omitempty" yaml:"target_pool_id"`
	TokenIn        github_com_cosmos_cosmos_sdk_types.Coin       `protobuf:"bytes,3,opt,name=tokenIn,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Coin" json:"tokenIn" yaml:"token_in"`
	MaxAmountIn    github_com_cosmos_cosmos_sdk_types.Int        `protobuf:"bytes,4,opt,name=maxAmountIn,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"maxAmountIn" yaml:"max_amount_in"`
	TokenOut       github_com_cosmos_cosmos_sdk_types.Coin       `protobuf:"bytes,5,opt,name=tokenOut,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Coin" json:"tokenOut" yaml:"token_out"`
	TokenAmountOut github_com_cosmos_cosmos_sdk_types.Int        `protobuf:"bytes,6,opt,name=tokenAmountOut,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"tokenAmountOut" yaml:"token_amount_out"`
	MaxPrice       github_com_cosmos_cosmos_sdk_types.Int        `protobuf:"bytes,7,opt,name=maxPrice,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"maxPrice" yaml:"max_price"`
}

func (m *MsgSwapExactAmountOut) Reset()         { *m = MsgSwapExactAmountOut{} }
func (m *MsgSwapExactAmountOut) String() string { return proto.CompactTextString(m) }
func (*MsgSwapExactAmountOut) ProtoMessage()    {}
func (*MsgSwapExactAmountOut) Descriptor() ([]byte, []int) {
	return fileDescriptor_cfc8fd3ac7df3247, []int{8}
}
func (m *MsgSwapExactAmountOut) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSwapExactAmountOut) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSwapExactAmountOut.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSwapExactAmountOut) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSwapExactAmountOut.Merge(m, src)
}
func (m *MsgSwapExactAmountOut) XXX_Size() int {
	return m.Size()
}
func (m *MsgSwapExactAmountOut) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSwapExactAmountOut.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSwapExactAmountOut proto.InternalMessageInfo

func (m *MsgSwapExactAmountOut) GetSender() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.Sender
	}
	return nil
}

func (m *MsgSwapExactAmountOut) GetTargetPoolId() uint64 {
	if m != nil {
		return m.TargetPoolId
	}
	return 0
}

// ===================== MsgJoinSwapExternAmountIn
type MsgJoinSwapExternAmountIn struct {
	Sender           github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,1,opt,name=sender,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"sender,omitempty" yaml:"sender"`
	TargetPool       uint64                                        `protobuf:"varint,2,opt,name=targetPool,proto3" json:"targetPool,omitempty" yaml:"target_pool"`
	TokenIn          string                                        `protobuf:"bytes,3,opt,name=tokenIn,proto3" json:"tokenIn,omitempty" yaml:"token_in"`
	TokenAmountIn    github_com_cosmos_cosmos_sdk_types.Int        `protobuf:"bytes,4,opt,name=tokenAmountIn,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"tokenAmountIn" yaml:"token_amount_in"`
	MinPoolAmountOut github_com_cosmos_cosmos_sdk_types.Int        `protobuf:"bytes,5,opt,name=minPoolAmountOut,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"minPoolAmountOut" yaml:"min_pool_amount_out"`
}

func (m *MsgJoinSwapExternAmountIn) Reset()         { *m = MsgJoinSwapExternAmountIn{} }
func (m *MsgJoinSwapExternAmountIn) String() string { return proto.CompactTextString(m) }
func (*MsgJoinSwapExternAmountIn) ProtoMessage()    {}
func (*MsgJoinSwapExternAmountIn) Descriptor() ([]byte, []int) {
	return fileDescriptor_cfc8fd3ac7df3247, []int{9}
}
func (m *MsgJoinSwapExternAmountIn) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgJoinSwapExternAmountIn) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgJoinSwapExternAmountIn.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgJoinSwapExternAmountIn) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgJoinSwapExternAmountIn.Merge(m, src)
}
func (m *MsgJoinSwapExternAmountIn) XXX_Size() int {
	return m.Size()
}
func (m *MsgJoinSwapExternAmountIn) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgJoinSwapExternAmountIn.DiscardUnknown(m)
}

var xxx_messageInfo_MsgJoinSwapExternAmountIn proto.InternalMessageInfo

func (m *MsgJoinSwapExternAmountIn) GetSender() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.Sender
	}
	return nil
}

func (m *MsgJoinSwapExternAmountIn) GetTargetPool() uint64 {
	if m != nil {
		return m.TargetPool
	}
	return 0
}

func (m *MsgJoinSwapExternAmountIn) GetTokenIn() string {
	if m != nil {
		return m.TokenIn
	}
	return ""
}

// ===================== MsgJoinSwapPoolAmountOut
type MsgJoinSwapPoolAmountOut struct {
	Sender        github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,1,opt,name=sender,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"sender,omitempty" yaml:"sender"`
	TargetPool    uint64                                        `protobuf:"varint,2,opt,name=targetPool,proto3" json:"targetPool,omitempty" yaml:"target_pool"`
	TokenIn       string                                        `protobuf:"bytes,3,opt,name=tokenIn,proto3" json:"tokenIn,omitempty" yaml:"token_in"`
	PoolAmountOut github_com_cosmos_cosmos_sdk_types.Int        `protobuf:"bytes,4,opt,name=poolAmountOut,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"poolAmountOut" yaml:"pool_amount_out"`
	MaxAmountIn   github_com_cosmos_cosmos_sdk_types.Int        `protobuf:"bytes,5,opt,name=maxAmountIn,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"maxAmountIn" yaml:"max_amount_in"`
}

func (m *MsgJoinSwapPoolAmountOut) Reset()         { *m = MsgJoinSwapPoolAmountOut{} }
func (m *MsgJoinSwapPoolAmountOut) String() string { return proto.CompactTextString(m) }
func (*MsgJoinSwapPoolAmountOut) ProtoMessage()    {}
func (*MsgJoinSwapPoolAmountOut) Descriptor() ([]byte, []int) {
	return fileDescriptor_cfc8fd3ac7df3247, []int{10}
}
func (m *MsgJoinSwapPoolAmountOut) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgJoinSwapPoolAmountOut) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgJoinSwapPoolAmountOut.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgJoinSwapPoolAmountOut) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgJoinSwapPoolAmountOut.Merge(m, src)
}
func (m *MsgJoinSwapPoolAmountOut) XXX_Size() int {
	return m.Size()
}
func (m *MsgJoinSwapPoolAmountOut) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgJoinSwapPoolAmountOut.DiscardUnknown(m)
}

var xxx_messageInfo_MsgJoinSwapPoolAmountOut proto.InternalMessageInfo

func (m *MsgJoinSwapPoolAmountOut) GetSender() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.Sender
	}
	return nil
}

func (m *MsgJoinSwapPoolAmountOut) GetTargetPool() uint64 {
	if m != nil {
		return m.TargetPool
	}
	return 0
}

func (m *MsgJoinSwapPoolAmountOut) GetTokenIn() string {
	if m != nil {
		return m.TokenIn
	}
	return ""
}

// ===================== MsgExitSwapExternAmountOut
type MsgExitSwapExternAmountOut struct {
	Sender       github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,1,opt,name=sender,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"sender,omitempty" yaml:"sender"`
	TargetPool   uint64                                        `protobuf:"varint,2,opt,name=targetPool,proto3" json:"targetPool,omitempty" yaml:"target_pool"`
	TokenOut     string                                        `protobuf:"bytes,3,opt,name=tokenOut,proto3" json:"tokenOut,omitempty" yaml:"token_out"`
	PoolAmountIn github_com_cosmos_cosmos_sdk_types.Int        `protobuf:"bytes,4,opt,name=poolAmountIn,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"poolAmountIn" yaml:"pool_amount_in"`
	MinAmountOut github_com_cosmos_cosmos_sdk_types.Int        `protobuf:"bytes,5,opt,name=minAmountOut,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"minAmountOut" yaml:"min_amount_out"`
}

func (m *MsgExitSwapExternAmountOut) Reset()         { *m = MsgExitSwapExternAmountOut{} }
func (m *MsgExitSwapExternAmountOut) String() string { return proto.CompactTextString(m) }
func (*MsgExitSwapExternAmountOut) ProtoMessage()    {}
func (*MsgExitSwapExternAmountOut) Descriptor() ([]byte, []int) {
	return fileDescriptor_cfc8fd3ac7df3247, []int{11}
}
func (m *MsgExitSwapExternAmountOut) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgExitSwapExternAmountOut) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgExitSwapExternAmountOut.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgExitSwapExternAmountOut) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgExitSwapExternAmountOut.Merge(m, src)
}
func (m *MsgExitSwapExternAmountOut) XXX_Size() int {
	return m.Size()
}
func (m *MsgExitSwapExternAmountOut) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgExitSwapExternAmountOut.DiscardUnknown(m)
}

var xxx_messageInfo_MsgExitSwapExternAmountOut proto.InternalMessageInfo

func (m *MsgExitSwapExternAmountOut) GetSender() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.Sender
	}
	return nil
}

func (m *MsgExitSwapExternAmountOut) GetTargetPool() uint64 {
	if m != nil {
		return m.TargetPool
	}
	return 0
}

func (m *MsgExitSwapExternAmountOut) GetTokenOut() string {
	if m != nil {
		return m.TokenOut
	}
	return ""
}

// ===================== MsgExitSwapPoolAmountIn
type MsgExitSwapPoolAmountIn struct {
	Sender          github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,1,opt,name=sender,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"sender,omitempty" yaml:"sender"`
	TargetPool      uint64                                        `protobuf:"varint,2,opt,name=targetPool,proto3" json:"targetPool,omitempty" yaml:"target_pool"`
	TokenOut        string                                        `protobuf:"bytes,3,opt,name=tokenOut,proto3" json:"tokenOut,omitempty" yaml:"token_out"`
	TokenAmountOut  github_com_cosmos_cosmos_sdk_types.Int        `protobuf:"bytes,4,opt,name=tokenAmountOut,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"tokenAmountOut" yaml:"token_amount_out"`
	MaxPoolAmountIn github_com_cosmos_cosmos_sdk_types.Int        `protobuf:"bytes,5,opt,name=maxPoolAmountIn,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"maxPoolAmountIn" yaml:"max_pool_amount_in"`
}

func (m *MsgExitSwapPoolAmountIn) Reset()         { *m = MsgExitSwapPoolAmountIn{} }
func (m *MsgExitSwapPoolAmountIn) String() string { return proto.CompactTextString(m) }
func (*MsgExitSwapPoolAmountIn) ProtoMessage()    {}
func (*MsgExitSwapPoolAmountIn) Descriptor() ([]byte, []int) {
	return fileDescriptor_cfc8fd3ac7df3247, []int{12}
}
func (m *MsgExitSwapPoolAmountIn) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgExitSwapPoolAmountIn) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgExitSwapPoolAmountIn.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgExitSwapPoolAmountIn) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgExitSwapPoolAmountIn.Merge(m, src)
}
func (m *MsgExitSwapPoolAmountIn) XXX_Size() int {
	return m.Size()
}
func (m *MsgExitSwapPoolAmountIn) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgExitSwapPoolAmountIn.DiscardUnknown(m)
}

var xxx_messageInfo_MsgExitSwapPoolAmountIn proto.InternalMessageInfo

func (m *MsgExitSwapPoolAmountIn) GetSender() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.Sender
	}
	return nil
}

func (m *MsgExitSwapPoolAmountIn) GetTargetPool() uint64 {
	if m != nil {
		return m.TargetPool
	}
	return 0
}

func (m *MsgExitSwapPoolAmountIn) GetTokenOut() string {
	if m != nil {
		return m.TokenOut
	}
	return ""
}

func init() {
	proto.RegisterType((*MaxAmountIn)(nil), "osmosis.gamm.v1beta1.MaxAmountIn")
	proto.RegisterType((*MsgJoinPool)(nil), "osmosis.gamm.v1beta1.MsgJoinPool")
	proto.RegisterType((*MinAmountOut)(nil), "osmosis.gamm.v1beta1.MinAmountOut")
	proto.RegisterType((*MsgExitPool)(nil), "osmosis.gamm.v1beta1.MsgExitPool")
	proto.RegisterType((*LPTokenInfo)(nil), "osmosis.gamm.v1beta1.LPTokenInfo")
	proto.RegisterType((*BindTokenInfo)(nil), "osmosis.gamm.v1beta1.BindTokenInfo")
	proto.RegisterType((*MsgCreatePool)(nil), "osmosis.gamm.v1beta1.MsgCreatePool")
	proto.RegisterType((*MsgSwapExactAmountIn)(nil), "osmosis.gamm.v1beta1.MsgSwapExactAmountIn")
	proto.RegisterType((*MsgSwapExactAmountOut)(nil), "osmosis.gamm.v1beta1.MsgSwapExactAmountOut")
	proto.RegisterType((*MsgJoinSwapExternAmountIn)(nil), "osmosis.gamm.v1beta1.MsgJoinSwapExternAmountIn")
	proto.RegisterType((*MsgJoinSwapPoolAmountOut)(nil), "osmosis.gamm.v1beta1.MsgJoinSwapPoolAmountOut")
	proto.RegisterType((*MsgExitSwapExternAmountOut)(nil), "osmosis.gamm.v1beta1.MsgExitSwapExternAmountOut")
	proto.RegisterType((*MsgExitSwapPoolAmountIn)(nil), "osmosis.gamm.v1beta1.MsgExitSwapPoolAmountIn")
}

func init() { proto.RegisterFile("osmosis/gamm/v1beta1/tx.proto", fileDescriptor_cfc8fd3ac7df3247) }

var fileDescriptor_cfc8fd3ac7df3247 = []byte{
	// 1071 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x98, 0x41, 0x6f, 0x1b, 0x45,
	0x14, 0xc7, 0xe3, 0xda, 0x4e, 0x9a, 0xb1, 0x4d, 0xc3, 0xe2, 0x24, 0x76, 0xa4, 0xda, 0x65, 0x90,
	0x4a, 0x39, 0x64, 0x4d, 0x41, 0x42, 0x08, 0x09, 0x55, 0x59, 0xd3, 0x82, 0xa1, 0x16, 0xd1, 0x52,
	0x09, 0xa9, 0x48, 0xb5, 0xd6, 0xbb, 0x93, 0xcd, 0x2a, 0xde, 0x99, 0xc5, 0x33, 0xc6, 0x2e, 0x9f,
	0x82, 0x23, 0x7c, 0x12, 0x2e, 0x7c, 0x80, 0x70, 0xeb, 0x11, 0x71, 0xb0, 0x50, 0xc2, 0x85, 0xab,
	0x8f, 0x1c, 0x00, 0xed, 0xcc, 0xec, 0xee, 0xac, 0x9d, 0xaa, 0x59, 0x45, 0x06, 0xab, 0xe2, 0x64,
	0xcb, 0x6f, 0xfc, 0xff, 0xcf, 0xbc, 0xf7, 0xdb, 0x37, 0x33, 0x0b, 0x6e, 0x12, 0xea, 0x13, 0xea,
	0xd1, 0x96, 0x6b, 0xf9, 0x7e, 0xeb, 0x9b, 0xbb, 0x7d, 0xc4, 0xac, 0xbb, 0x2d, 0x36, 0xd1, 0x83,
	0x21, 0x61, 0x44, 0xab, 0xca, 0xb0, 0x1e, 0x86, 0x75, 0x19, 0xde, 0xab, 0xba, 0xc4, 0x25, 0x7c,
	0x40, 0x2b, 0xfc, 0x26, 0xc6, 0xee, 0x35, 0x6c, 0x3e, 0xb8, 0xd5, 0xb7, 0x28, 0x8a, 0x95, 0x6c,
	0xe2, 0x61, 0x11, 0x87, 0xdf, 0xe7, 0x40, 0xa9, 0x6b, 0x4d, 0x0e, 0x7c, 0x32, 0xc2, 0xac, 0x83,
	0xb5, 0xdb, 0xa0, 0xe8, 0x20, 0x4c, 0xfc, 0x5a, 0xee, 0x56, 0xee, 0xce, 0xa6, 0xb1, 0x35, 0x9b,
	0x36, 0xcb, 0x4f, 0x2d, 0x7f, 0xf0, 0x01, 0xe4, 0x3f, 0x43, 0x53, 0x84, 0x35, 0x0b, 0x6c, 0xfa,
	0xd1, 0xdf, 0x6a, 0xd7, 0xf8, 0xd8, 0xf6, 0xe9, 0xb4, 0xb9, 0xf6, 0xeb, 0xb4, 0x79, 0xdb, 0xf5,
	0xd8, 0xf1, 0xa8, 0xaf, 0xdb, 0xc4, 0x6f, 0x49, 0x77, 0xf1, 0xb1, 0x4f, 0x9d, 0x93, 0x16, 0x7b,
	0x1a, 0x20, 0xaa, 0x77, 0x30, 0x9b, 0x4d, 0x9b, 0xaf, 0x0a, 0x65, 0xdf, 0x9a, 0xf4, 0x2c, 0xae,
	0x04, 0xcd, 0x44, 0x15, 0xfe, 0x75, 0x0d, 0x94, 0xba, 0xd4, 0xfd, 0x94, 0x78, 0xf8, 0x90, 0x90,
	0x81, 0xf6, 0x18, 0xac, 0x53, 0x84, 0x1d, 0x34, 0xe4, 0x73, 0x2b, 0x1b, 0xc6, 0x6c, 0xda, 0xac,
	0x08, 0x05, 0xf1, 0x3b, 0xfc, 0x73, 0xda, 0xdc, 0xbf, 0x84, 0xf9, 0x81, 0x6d, 0x1f, 0x38, 0xce,
	0x10, 0x51, 0x6a, 0x4a, 0x45, 0xed, 0x43, 0x50, 0x66, 0xd6, 0xd0, 0x45, 0x2c, 0x74, 0xea, 0x38,
	0x7c, 0x45, 0x05, 0xa3, 0x3e, 0x9b, 0x36, 0xb7, 0x85, 0x83, 0x88, 0xf6, 0x02, 0x42, 0x06, 0x3d,
	0xcf, 0x81, 0x66, 0x6a, 0xb8, 0x86, 0x41, 0x25, 0x8c, 0x88, 0x89, 0x7f, 0x3e, 0x62, 0xb5, 0x3c,
	0xcf, 0xc8, 0x27, 0x99, 0x33, 0xb2, 0x23, 0xdc, 0xb8, 0x8d, 0x48, 0x49, 0x8f, 0x8c, 0x18, 0x34,
	0xd3, 0xf2, 0x9a, 0x03, 0xca, 0x71, 0x9e, 0x68, 0x07, 0xd7, 0x0a, 0xb7, 0xf2, 0x77, 0x4a, 0xef,
	0xbc, 0xae, 0x5f, 0x04, 0x86, 0xae, 0x94, 0xd7, 0xb8, 0x19, 0xce, 0x28, 0x59, 0x55, 0x92, 0x79,
	0xda, 0xf3, 0x30, 0x34, 0x53, 0xaa, 0xf0, 0x87, 0x1c, 0x28, 0x77, 0x3d, 0x9c, 0xd8, 0x66, 0x81,
	0x23, 0xfa, 0xdf, 0x95, 0xe1, 0xf0, 0xb0, 0x02, 0x47, 0xa4, 0x0a, 0xff, 0x16, 0x70, 0xdc, 0x9f,
	0x78, 0x6c, 0xd5, 0xe1, 0x38, 0x01, 0xe5, 0xa4, 0x7a, 0x1d, 0x2c, 0xd9, 0xf8, 0x38, 0x73, 0x42,
	0xb6, 0x17, 0xd9, 0xe0, 0x35, 0x53, 0xc5, 0xb5, 0x63, 0x50, 0x89, 0x93, 0x44, 0x43, 0x12, 0x05,
	0x1a, 0xf0, 0x39, 0x68, 0x28, 0xd5, 0x35, 0x1a, 0x92, 0x8d, 0x9d, 0xf9, 0xc4, 0x53, 0xc9, 0x60,
	0x4a, 0x18, 0x12, 0x50, 0x7a, 0x78, 0xf8, 0x88, 0x9c, 0x20, 0xdc, 0xc1, 0x47, 0xe4, 0xd2, 0x6c,
	0xbc, 0x0f, 0x4a, 0x0e, 0xa2, 0xf6, 0xd0, 0x0b, 0x98, 0x47, 0xb0, 0xa4, 0x63, 0x67, 0x36, 0x6d,
	0x6a, 0xd1, 0xe8, 0x38, 0x08, 0x4d, 0x75, 0x28, 0xfc, 0x23, 0x07, 0x2a, 0x86, 0x87, 0x9d, 0xec,
	0x9e, 0x5f, 0x82, 0xf5, 0x31, 0xf2, 0xdc, 0xe3, 0x08, 0xc6, 0x7b, 0x19, 0x72, 0xff, 0x11, 0xb2,
	0x13, 0x94, 0x84, 0x0a, 0x34, 0xa5, 0x5c, 0x28, 0x2c, 0x52, 0x24, 0x8b, 0x7a, 0x2f, 0x73, 0x51,
	0xa5, 0x70, 0x44, 0xb8, 0x94, 0x0b, 0x7b, 0x5f, 0xa5, 0x4b, 0xdd, 0xf6, 0x10, 0x59, 0x0c, 0x2d,
	0x1d, 0xf0, 0xaf, 0xc0, 0x06, 0x1d, 0x5b, 0xc1, 0x03, 0x84, 0x64, 0x82, 0x0e, 0x32, 0x27, 0xe8,
	0x86, 0x9c, 0xca, 0xd8, 0x0a, 0x7a, 0x47, 0x08, 0x41, 0x33, 0x52, 0xd4, 0x1e, 0x81, 0x8d, 0x41,
	0xc0, 0x6b, 0xc6, 0x93, 0xf4, 0xdc, 0x36, 0xa5, 0xc0, 0x64, 0xec, 0x4a, 0x14, 0xa5, 0xea, 0x20,
	0xe8, 0xb1, 0x30, 0x06, 0xcd, 0x48, 0x4a, 0x7b, 0x02, 0x40, 0x3f, 0x62, 0x81, 0x4a, 0xc8, 0xdf,
	0xb8, 0x58, 0x38, 0xc5, 0x8c, 0x51, 0x97, 0xd2, 0xb2, 0xbd, 0x70, 0xdd, 0x9e, 0x87, 0x8f, 0x08,
	0x34, 0x15, 0x45, 0x78, 0x5e, 0x04, 0xd5, 0x2e, 0x75, 0xbf, 0x18, 0x5b, 0xc1, 0xfd, 0x89, 0x65,
	0xb3, 0xf8, 0x01, 0x5b, 0xe1, 0x46, 0x33, 0x06, 0x1b, 0x4c, 0xac, 0x53, 0x66, 0xba, 0xae, 0x0b,
	0x57, 0x3d, 0xdc, 0xfd, 0xe3, 0x7c, 0xb4, 0x89, 0x87, 0x0d, 0x43, 0x56, 0xf8, 0xcd, 0x4b, 0xcc,
	0x34, 0xfc, 0x43, 0x52, 0x8c, 0x28, 0x63, 0xd0, 0x8c, 0xdc, 0xc2, 0xed, 0x8f, 0x7f, 0x8d, 0x5b,
	0x5c, 0xe1, 0x6a, 0xdb, 0x9f, 0xb0, 0x50, 0x7a, 0x5c, 0x5a, 0x5e, 0xfb, 0x16, 0x5c, 0xe7, 0x3f,
	0x84, 0xfd, 0xad, 0xf8, 0xa2, 0x95, 0xb6, 0xb3, 0xaf, 0x74, 0x4b, 0x9d, 0x06, 0xef, 0x7d, 0xb1,
	0x5f, 0xd8, 0xcd, 0x7d, 0xa5, 0x6b, 0xd6, 0xd6, 0xaf, 0xd6, 0xcd, 0x93, 0x2e, 0x2b, 0x8c, 0x52,
	0xe2, 0xda, 0x13, 0x70, 0xdd, 0xb7, 0x26, 0x87, 0x43, 0xcf, 0x46, 0xb5, 0x0d, 0x6e, 0x64, 0x64,
	0x36, 0xda, 0x4a, 0xb6, 0xfa, 0x20, 0x14, 0x82, 0x66, 0xac, 0x09, 0x7f, 0x2f, 0x82, 0xed, 0x45,
	0xca, 0x43, 0xe7, 0xff, 0x31, 0x5f, 0xc4, 0xfc, 0x18, 0x94, 0xfc, 0xe4, 0x2c, 0x25, 0x21, 0x7f,
	0x90, 0xb9, 0x20, 0xd5, 0xf9, 0xb3, 0x17, 0x77, 0x51, 0xa5, 0xff, 0x53, 0xc0, 0xbf, 0x06, 0xaf,
	0x28, 0x4f, 0x5b, 0x82, 0x78, 0x27, 0xf3, 0x42, 0x77, 0x2f, 0x78, 0x9a, 0xb9, 0xd9, 0x9c, 0xc1,
	0xd2, 0x31, 0x3f, 0xcd, 0x83, 0xba, 0xbc, 0x49, 0x08, 0xd4, 0x19, 0x1a, 0xe2, 0x7f, 0xa5, 0xa3,
	0xbf, 0x07, 0x40, 0xc2, 0xae, 0x04, 0x5d, 0x39, 0xec, 0x28, 0xa0, 0x43, 0x53, 0x19, 0xa9, 0xed,
	0xa7, 0x19, 0xdf, 0x34, 0x5e, 0x5b, 0xa9, 0x06, 0x3c, 0x01, 0x5b, 0xbe, 0xb8, 0x95, 0x25, 0x94,
	0x14, 0xb9, 0xe5, 0xc3, 0xcc, 0x96, 0x7b, 0x49, 0x23, 0x5c, 0xb8, 0xf6, 0x2c, 0xb8, 0xc0, 0x1f,
	0xf3, 0xa0, 0xa6, 0x94, 0x32, 0x15, 0x7c, 0x49, 0x2a, 0x99, 0xbe, 0x49, 0x16, 0x96, 0x7b, 0x93,
	0x9c, 0xeb, 0x69, 0xc5, 0xa5, 0xf5, 0x34, 0xf8, 0x53, 0x1e, 0xec, 0xc9, 0x1b, 0xdb, 0xfc, 0x43,
	0xb8, 0xaa, 0xb5, 0x7b, 0x5b, 0x69, 0xc3, 0xa2, 0x78, 0xd5, 0x17, 0x9f, 0x0e, 0x52, 0x77, 0xbd,
	0xc2, 0x32, 0xef, 0x7a, 0xf3, 0x47, 0x91, 0xe2, 0x12, 0x8f, 0x22, 0xf0, 0xe7, 0x3c, 0xd8, 0x55,
	0xca, 0x77, 0xa8, 0x4e, 0xe4, 0xe5, 0xa8, 0xdd, 0xe2, 0xc6, 0x57, 0x58, 0xf6, 0xc6, 0x37, 0x02,
	0x37, 0xc2, 0x4d, 0x4a, 0x25, 0x46, 0x14, 0xf1, 0xb3, 0xcc, 0x9e, 0x75, 0x65, 0xff, 0x9b, 0xa3,
	0x66, 0xde, 0xc3, 0x68, 0x9f, 0x9e, 0x35, 0x72, 0xcf, 0xce, 0x1a, 0xb9, 0xdf, 0xce, 0x1a, 0xb9,
	0xef, 0xce, 0x1b, 0x6b, 0xcf, 0xce, 0x1b, 0x6b, 0xbf, 0x9c, 0x37, 0xd6, 0x1e, 0xbf, 0xa5, 0xfa,
	0xed, 0x47, 0xaf, 0x21, 0xa3, 0xcf, 0x89, 0x78, 0x21, 0xc9, 0x6d, 0xfb, 0xeb, 0xfc, 0x05, 0xe2,
	0xbb, 0xff, 0x04, 0x00, 0x00, 0xff, 0xff, 0xb4, 0x07, 0xca, 0x79, 0xad, 0x14, 0x00, 0x00,
}

func (m *MaxAmountIn) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MaxAmountIn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MaxAmountIn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.MaxAmount.Size()
		i -= size
		if _, err := m.MaxAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgJoinPool) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgJoinPool) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgJoinPool) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MaxAmountsIn) > 0 {
		for iNdEx := len(m.MaxAmountsIn) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MaxAmountsIn[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	{
		size := m.PoolAmountOut.Size()
		i -= size
		if _, err := m.PoolAmountOut.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.TargetPoolId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.TargetPoolId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MinAmountOut) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MinAmountOut) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MinAmountOut) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.MinAmount.Size()
		i -= size
		if _, err := m.MinAmount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgExitPool) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgExitPool) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgExitPool) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MinAmountsOut) > 0 {
		for iNdEx := len(m.MinAmountsOut) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MinAmountsOut[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	{
		size := m.PoolAmountIn.Size()
		i -= size
		if _, err := m.PoolAmountIn.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.TargetPoolId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.TargetPoolId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LPTokenInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LPTokenInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LPTokenInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BindTokenInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BindTokenInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BindTokenInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.Weight.Size()
		i -= size
		if _, err := m.Weight.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreatePool) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreatePool) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreatePool) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BindTokens) > 0 {
		for iNdEx := len(m.BindTokens) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BindTokens[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	{
		size, err := m.LpToken.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.SwapFee.Size()
		i -= size
		if _, err := m.SwapFee.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSwapExactAmountIn) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSwapExactAmountIn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSwapExactAmountIn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.MaxPrice.Size()
		i -= size
		if _, err := m.MaxPrice.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size := m.MinAmountOut.Size()
		i -= size
		if _, err := m.MinAmountOut.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size := m.TokenOut.Size()
		i -= size
		if _, err := m.TokenOut.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.TokenAmountIn.Size()
		i -= size
		if _, err := m.TokenAmountIn.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.TokenIn.Size()
		i -= size
		if _, err := m.TokenIn.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.TargetPoolId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.TargetPoolId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSwapExactAmountOut) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSwapExactAmountOut) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSwapExactAmountOut) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.MaxPrice.Size()
		i -= size
		if _, err := m.MaxPrice.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size := m.TokenAmountOut.Size()
		i -= size
		if _, err := m.TokenAmountOut.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size := m.TokenOut.Size()
		i -= size
		if _, err := m.TokenOut.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.MaxAmountIn.Size()
		i -= size
		if _, err := m.MaxAmountIn.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.TokenIn.Size()
		i -= size
		if _, err := m.TokenIn.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.TargetPoolId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.TargetPoolId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgJoinSwapExternAmountIn) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgJoinSwapExternAmountIn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgJoinSwapExternAmountIn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.MinPoolAmountOut.Size()
		i -= size
		if _, err := m.MinPoolAmountOut.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.TokenAmountIn.Size()
		i -= size
		if _, err := m.TokenAmountIn.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.TokenIn) > 0 {
		i -= len(m.TokenIn)
		copy(dAtA[i:], m.TokenIn)
		i = encodeVarintTx(dAtA, i, uint64(len(m.TokenIn)))
		i--
		dAtA[i] = 0x1a
	}
	if m.TargetPool != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.TargetPool))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgJoinSwapPoolAmountOut) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgJoinSwapPoolAmountOut) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgJoinSwapPoolAmountOut) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.MaxAmountIn.Size()
		i -= size
		if _, err := m.MaxAmountIn.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.PoolAmountOut.Size()
		i -= size
		if _, err := m.PoolAmountOut.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.TokenIn) > 0 {
		i -= len(m.TokenIn)
		copy(dAtA[i:], m.TokenIn)
		i = encodeVarintTx(dAtA, i, uint64(len(m.TokenIn)))
		i--
		dAtA[i] = 0x1a
	}
	if m.TargetPool != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.TargetPool))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgExitSwapExternAmountOut) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgExitSwapExternAmountOut) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgExitSwapExternAmountOut) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.MinAmountOut.Size()
		i -= size
		if _, err := m.MinAmountOut.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.PoolAmountIn.Size()
		i -= size
		if _, err := m.PoolAmountIn.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.TokenOut) > 0 {
		i -= len(m.TokenOut)
		copy(dAtA[i:], m.TokenOut)
		i = encodeVarintTx(dAtA, i, uint64(len(m.TokenOut)))
		i--
		dAtA[i] = 0x1a
	}
	if m.TargetPool != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.TargetPool))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgExitSwapPoolAmountIn) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgExitSwapPoolAmountIn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgExitSwapPoolAmountIn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.MaxPoolAmountIn.Size()
		i -= size
		if _, err := m.MaxPoolAmountIn.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.TokenAmountOut.Size()
		i -= size
		if _, err := m.TokenAmountOut.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.TokenOut) > 0 {
		i -= len(m.TokenOut)
		copy(dAtA[i:], m.TokenOut)
		i = encodeVarintTx(dAtA, i, uint64(len(m.TokenOut)))
		i--
		dAtA[i] = 0x1a
	}
	if m.TargetPool != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.TargetPool))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTx(dAtA []byte, offset int, v uint64) int {
	offset -= sovTx(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MaxAmountIn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.MaxAmount.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgJoinPool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.TargetPoolId != 0 {
		n += 1 + sovTx(uint64(m.TargetPoolId))
	}
	l = m.PoolAmountOut.Size()
	n += 1 + l + sovTx(uint64(l))
	if len(m.MaxAmountsIn) > 0 {
		for _, e := range m.MaxAmountsIn {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MinAmountOut) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.MinAmount.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgExitPool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.TargetPoolId != 0 {
		n += 1 + sovTx(uint64(m.TargetPoolId))
	}
	l = m.PoolAmountIn.Size()
	n += 1 + l + sovTx(uint64(l))
	if len(m.MinAmountsOut) > 0 {
		for _, e := range m.MinAmountsOut {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *LPTokenInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *BindTokenInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Weight.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.Amount.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgCreatePool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.SwapFee.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.LpToken.Size()
	n += 1 + l + sovTx(uint64(l))
	if len(m.BindTokens) > 0 {
		for _, e := range m.BindTokens {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgSwapExactAmountIn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.TargetPoolId != 0 {
		n += 1 + sovTx(uint64(m.TargetPoolId))
	}
	l = m.TokenIn.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.TokenAmountIn.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.TokenOut.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.MinAmountOut.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.MaxPrice.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgSwapExactAmountOut) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.TargetPoolId != 0 {
		n += 1 + sovTx(uint64(m.TargetPoolId))
	}
	l = m.TokenIn.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.MaxAmountIn.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.TokenOut.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.TokenAmountOut.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.MaxPrice.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgJoinSwapExternAmountIn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.TargetPool != 0 {
		n += 1 + sovTx(uint64(m.TargetPool))
	}
	l = len(m.TokenIn)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.TokenAmountIn.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.MinPoolAmountOut.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgJoinSwapPoolAmountOut) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.TargetPool != 0 {
		n += 1 + sovTx(uint64(m.TargetPool))
	}
	l = len(m.TokenIn)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.PoolAmountOut.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.MaxAmountIn.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgExitSwapExternAmountOut) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.TargetPool != 0 {
		n += 1 + sovTx(uint64(m.TargetPool))
	}
	l = len(m.TokenOut)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.PoolAmountIn.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.MinAmountOut.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgExitSwapPoolAmountIn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.TargetPool != 0 {
		n += 1 + sovTx(uint64(m.TargetPool))
	}
	l = len(m.TokenOut)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.TokenAmountOut.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.MaxPoolAmountIn.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func sovTx(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTx(x uint64) (n int) {
	return sovTx(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MaxAmountIn) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MaxAmountIn: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MaxAmountIn: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaxAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgJoinPool) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgJoinPool: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgJoinPool: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = append(m.Sender[:0], dAtA[iNdEx:postIndex]...)
			if m.Sender == nil {
				m.Sender = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetPoolId", wireType)
			}
			m.TargetPoolId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetPoolId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolAmountOut", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PoolAmountOut.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxAmountsIn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MaxAmountsIn = append(m.MaxAmountsIn, MaxAmountIn{})
			if err := m.MaxAmountsIn[len(m.MaxAmountsIn)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MinAmountOut) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MinAmountOut: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MinAmountOut: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgExitPool) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgExitPool: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgExitPool: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = append(m.Sender[:0], dAtA[iNdEx:postIndex]...)
			if m.Sender == nil {
				m.Sender = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetPoolId", wireType)
			}
			m.TargetPoolId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetPoolId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolAmountIn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PoolAmountIn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinAmountsOut", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MinAmountsOut = append(m.MinAmountsOut, MinAmountOut{})
			if err := m.MinAmountsOut[len(m.MinAmountsOut)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LPTokenInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LPTokenInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LPTokenInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BindTokenInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BindTokenInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BindTokenInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weight", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Weight.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreatePool) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreatePool: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreatePool: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = append(m.Sender[:0], dAtA[iNdEx:postIndex]...)
			if m.Sender == nil {
				m.Sender = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwapFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SwapFee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LpToken", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LpToken.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BindTokens", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BindTokens = append(m.BindTokens, BindTokenInfo{})
			if err := m.BindTokens[len(m.BindTokens)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSwapExactAmountIn) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSwapExactAmountIn: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSwapExactAmountIn: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = append(m.Sender[:0], dAtA[iNdEx:postIndex]...)
			if m.Sender == nil {
				m.Sender = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetPoolId", wireType)
			}
			m.TargetPoolId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetPoolId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenIn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TokenIn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenAmountIn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TokenAmountIn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenOut", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TokenOut.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinAmountOut", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinAmountOut.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxPrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaxPrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSwapExactAmountOut) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSwapExactAmountOut: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSwapExactAmountOut: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = append(m.Sender[:0], dAtA[iNdEx:postIndex]...)
			if m.Sender == nil {
				m.Sender = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetPoolId", wireType)
			}
			m.TargetPoolId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetPoolId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenIn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TokenIn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxAmountIn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaxAmountIn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenOut", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TokenOut.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenAmountOut", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TokenAmountOut.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxPrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaxPrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgJoinSwapExternAmountIn) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgJoinSwapExternAmountIn: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgJoinSwapExternAmountIn: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = append(m.Sender[:0], dAtA[iNdEx:postIndex]...)
			if m.Sender == nil {
				m.Sender = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetPool", wireType)
			}
			m.TargetPool = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetPool |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenIn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenIn = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenAmountIn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TokenAmountIn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinPoolAmountOut", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinPoolAmountOut.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgJoinSwapPoolAmountOut) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgJoinSwapPoolAmountOut: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgJoinSwapPoolAmountOut: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = append(m.Sender[:0], dAtA[iNdEx:postIndex]...)
			if m.Sender == nil {
				m.Sender = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetPool", wireType)
			}
			m.TargetPool = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetPool |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenIn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenIn = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolAmountOut", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PoolAmountOut.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxAmountIn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaxAmountIn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgExitSwapExternAmountOut) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgExitSwapExternAmountOut: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgExitSwapExternAmountOut: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = append(m.Sender[:0], dAtA[iNdEx:postIndex]...)
			if m.Sender == nil {
				m.Sender = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetPool", wireType)
			}
			m.TargetPool = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetPool |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenOut", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenOut = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolAmountIn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PoolAmountIn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinAmountOut", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinAmountOut.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgExitSwapPoolAmountIn) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgExitSwapPoolAmountIn: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgExitSwapPoolAmountIn: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = append(m.Sender[:0], dAtA[iNdEx:postIndex]...)
			if m.Sender == nil {
				m.Sender = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetPool", wireType)
			}
			m.TargetPool = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetPool |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenOut", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenOut = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenAmountOut", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TokenAmountOut.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxPoolAmountIn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaxPoolAmountIn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTx(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTx
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTx
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTx
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTx
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTx        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTx          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTx = fmt.Errorf("proto: unexpected end of group")
)
